<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Image Ratio Checker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
        }

        .main-content {
            flex: 1;
        }

        .toolkit {
            width: 300px;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            height: fit-content;
            position: sticky;
            top: 20px;
        }

        .toolkit h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background-color: #f9f9f9;
        }

        .control-group h4 {
            margin: 0 0 10px 0;
            color: #555;
            font-size: 14px;
        }

        .control-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .control-item label {
            font-size: 12px;
            color: #666;
            min-width: 80px;
        }

        .control-item input[type="checkbox"] {
            margin: 0;
        }

        .control-item input[type="number"] {
            width: 60px;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 12px;
        }

        .padding-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .padding-all {
            grid-column: 1 / -1;
            margin-bottom: 8px;
        }

        .axis-controls {
            display: flex;
            gap: 10px;
            margin-top: 8px;
        }

        .incorrect-dimensions {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }

        .incorrect-dimensions h4 {
            color: #fd7e14;
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .compact-incorrect-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .compact-incorrect-item {
            font-size: 11px;
            padding: 2px 4px;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 3px;
            border: 1px solid #ffeaa7;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .compact-incorrect-item:hover {
            background-color: #fff8dc !important;
        }

        .missing-images {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }

        .missing-images h4 {
            color: #dc3545;
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .missing-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .missing-item {
            background-color: #f8d7da;
            color: #721c24;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 11px;
            border: 1px solid #f5c6cb;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: default;
        }

        .unused-images {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }

        .unused-images h4 {
            color: #6c757d;
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .unused-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .unused-item {
            background-color: #e2e3e5;
            color: #383d41;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 11px;
            border: 1px solid #d6d8db;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .unused-item:hover {
            background-color: #d6d8db !important;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .image-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .image-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            container-type: inline-size;
        }

        .image-container {
            position: relative;
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
            background-color: #f8f9fa;
        }

        .correct-dimensions .image-container {
            background-color: #f8f9fa;
        }

        .image-item img {
            max-width: 100%;
            max-height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: block;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .grid-line-v {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #ff0000;
            transform: translateX(-50%);
        }

        .grid-line-h {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #ff0000;
            transform: translateY(-50%);
        }

        .grid-line-division-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #ff6600;
        }

        .grid-line-division-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #ff6600;
        }

        .padding-line-top {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #0066ff;
        }

        .padding-line-bottom {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background-color: #0066ff;
        }

        .padding-line-left {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #0066ff;
        }

        .padding-line-right {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: #0066ff;
        }

        .visual-center-marker {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #ff00ff;
            border: 2px solid #ffffff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }

        .visual-center-marker[style*="background-color: rgb(255, 152, 0)"] {
            /* Estimated center marker styling */
            border-style: dashed;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .image-info {
            margin-top: 10px;
            font-size: clamp(8px, 5cqw, 14px);
            color: #666;
        }

        .filename {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .dimensions {
            color: #007acc;
        }



        .correct-dimensions {
            background-color: #d4edda !important;
            border: 2px solid #28a745;
        }



        .missing-images {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }

        .missing-images h4 {
            color: #dc3545;
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .missing-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .missing-list li {
            list-style: none;
            position: relative;
            padding: 0;
            margin: 0;
        }

        .unused-images {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            background-color: #f9f9f9;
        }

        .unused-images h4 {
            color: #6c757d;
            margin: 0 0 8px 0;
            font-size: 14px;
        }

        .unused-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .unused-item {
            background-color: #e2e3e5;
            color: #383d41;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 11px;
            border: 1px solid #d6d8db;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .unused-item:hover {
            background-color: #d6d8db !important;
        }

        .compact-incorrect-list {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .compact-incorrect-item {
            font-size: 11px;
            padding: 2px 4px;
            background-color: #fff3cd;
            color: #856404;
            border-radius: 3px;
            border: 1px solid #ffeaa7;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .compact-incorrect-item:hover {
            background-color: #fff8dc !important;
        }

        .breadcrumb-info {
            margin-top: 8px;
            font-size: clamp(6px, 3cqw, 10px);
            color: #888;
            line-height: 1.2;
            text-align: left;
        }

        .breadcrumb-path {
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 2px;
            margin: 1px 0;
            font-family: monospace;
            display: block;
            word-break: break-all;
        }

        /* Category color coding */
        .breadcrumb-path.category-hr {
            background-color: #e3f2fd;
            border-left: 3px solid #2196f3;
        }

        .breadcrumb-path.category-settings {
            background-color: #f3e5f5;
            border-left: 3px solid #9c27b0;
        }

        .breadcrumb-path.category-profile {
            background-color: #e8f5e8;
            border-left: 3px solid #4caf50;
        }

        .breadcrumb-path.category-request {
            background-color: #fff3e0;
            border-left: 3px solid #ff9800;
        }

        .breadcrumb-path.category-other {
            background-color: #fce4ec;
            border-left: 3px solid #e91e63;
        }

        .breadcrumb-path.category-shared {
            background-color: #f1f8e9;
            border-left: 3px solid #8bc34a;
        }

        .missing-item {
            background-color: #f8d7da;
            color: #721c24;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 11px;
            border: 1px solid #f5c6cb;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: default;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="main-content">
            <div style="display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px;">
                <h1 style="margin: 0;">SVG Image Ratio Checker</h1>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label for="mainCorrectDimensionCheck" style="font-size: 14px; color: #666;">Highlight Correct
                            Dimensions</label>
                        <input type="checkbox" id="mainCorrectDimensionCheck" checked style="transform: scale(1.2);">
                    </div>
                    <div class="filter-dropdown-container" style="position: relative;">
                        <button id="filterDropdownBtn" style="padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px; background: white; cursor: pointer; font-size: 14px;">
                            Filters ‚ñº
                        </button>
                        <div id="filterDropdown" style="display: none; position: absolute; top: 100%; left: 0; background: white; border: 1px solid #ccc; border-radius: 4px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 250px; padding: 15px;">
                            <!-- Usage Filter -->
                            <div style="margin-bottom: 15px;">
                                <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #333;">Usage Filter</h4>
                                <div style="display: flex; flex-direction: column; gap: 5px;">
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="radio" name="usageFilter" value="all" checked>
                                        All Images
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="radio" name="usageFilter" value="used">
                                        Used Images Only
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="radio" name="usageFilter" value="unused">
                                        Unused Images Only
                                    </label>
                                </div>
                            </div>

                            <!-- Dimension Filter -->
                            <div style="margin-bottom: 15px;">
                                <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #333;">Dimension Filter</h4>
                                <div style="display: flex; flex-direction: column; gap: 5px;">
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="dimension-filter" value="correct" checked>
                                        <span style="color: #28a745;">‚óè</span> Correct Dimensions (196√ó121)
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="dimension-filter" value="incorrect" checked>
                                        <span style="color: #fd7e14;">‚óè</span> Incorrect Dimensions
                                    </label>
                                </div>
                            </div>

                            <!-- Category Filter -->
                            <div>
                                <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #333;">Category Filter</h4>
                                <div style="display: flex; flex-direction: column; gap: 5px;">
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px; font-weight: bold; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 5px;">
                                        <input type="checkbox" id="selectAllCategories" checked>
                                        Select All
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="hr" checked>
                                        <span style="color: #2196f3;">‚óè</span> HR
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="settings" checked>
                                        <span style="color: #9c27b0;">‚óè</span> Settings
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="profile" checked>
                                        <span style="color: #4caf50;">‚óè</span> Profile
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="request" checked>
                                        <span style="color: #ff9800;">‚óè</span> Request
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="other" checked>
                                        <span style="color: #e91e63;">‚óè</span> Other
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; font-size: 13px;">
                                        <input type="checkbox" class="category-filter" value="shared" checked>
                                        <span style="color: #8bc34a;">‚óè</span> Shared
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label for="gridSizeSlider" style="font-size: 14px; color: #666;">Grid Size:</label>
                        <input type="range" id="gridSizeSlider" min="1" max="10" value="4" style="width: 100px;">
                        <span id="gridSizeValue" style="font-size: 12px; color: #888; min-width: 20px;">4</span>
                    </div>
                </div>
            </div>
            <div class="image-grid" id="imageGrid">
            </div>
        </div>

        <div class="toolkit">
            <!-- Incorrect Dimensions List (Compact) -->    
            <div class="incorrect-dimensions" id="incorrectDimensions" style="margin-bottom: 15px; display: none;">
                <h4 style="margin: 0 0 8px 0; color: #fd7e14; font-size: 14px;" id="incorrectDimensionsTitle">Incorrect
                    Dimensions</h4>
                <ol class="compact-incorrect-list" id="incorrectList">
                    <!-- Incorrect dimension images will be populated here -->
                </ol>
            </div>

            <!-- Missing Names List (Compact) -->
            <div class="missing-images" id="missingImages" style="margin-bottom: 15px; display: none;">
                <h4 style="margin: 0 0 8px 0; color: #dc3545; font-size: 14px;" id="missingTitle">Missing Names</h4>
                <ol class="missing-list" id="missingList">
                    <!-- Missing images will be populated here -->
                </ol>
            </div>

            <!-- Unused Images List (Compact) -->
            <div class="unused-images" id="unusedImages" style="margin-bottom: 15px; display: none;">
                <h4 style="margin: 0 0 8px 0; color: #6c757d; font-size: 14px;" id="unusedTitle">Unused Images</h4>
                <ol class="unused-list" id="unusedList">
                    <!-- Unused images will be populated here -->
                </ol>
            </div>

            <h3>Guide Line Toolkit</h3>

            <!-- Combined Guidelines Controls -->
            <div class="control-group">
                <h4>Guidelines</h4>



                <!-- Center Guidelines -->
                <div style="display: flex; gap: 15px; margin: 8px 0;">
                    <div class="control-item" style="margin-bottom: 0;">
                        <input type="checkbox" id="centerVertical" checked>
                        <label for="centerVertical">Vertical Center</label>
                    </div>
                    <div class="control-item" style="margin-bottom: 0;">
                        <input type="checkbox" id="centerHorizontal" checked>
                        <label for="centerHorizontal">Horizontal Center</label>
                    </div>
                </div>

                <!-- Visual Center Marker -->
                <div class="control-item">
                    <input type="checkbox" id="showVisualCenter">
                    <label for="showVisualCenter">Show Visual Center</label>
                </div>

                <!-- Division Guidelines -->
                <div class="control-item">
                    <input type="checkbox" id="enableVerticalDivisions">
                    <label for="enableVerticalDivisions">Vertical Divisions:</label>
                    <input type="number" id="verticalDivisions" min="2" max="10" value="3">
                    <span id="verticalDivisionValue" style="font-size: 10px; color: #888; margin-left: 4px;">65px</span>
                </div>
                <div class="control-item">
                    <input type="checkbox" id="enableHorizontalDivisions">
                    <label for="enableHorizontalDivisions">Horizontal Divisions:</label>
                    <input type="number" id="horizontalDivisions" min="2" max="10" value="3">
                    <span id="horizontalDivisionValue"
                        style="font-size: 10px; color: #888; margin-left: 4px;">40px</span>
                </div>
            </div>

            <!-- Padding Guidelines -->
            <div class="control-group">
                <h4>Padding Guidelines</h4>

                <!-- All Padding -->
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <input type="checkbox" id="enableAllPadding">
                    <label for="enableAllPadding" style="min-width: 80px;">All Padding:</label>
                    <input type="number" id="allPadding" min="0" max="100" value="15" style="width: 60px;">
                    <span style="font-size: 12px;">px</span>
                </div>

                <!-- Individual Padding in 2x2 Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="checkbox" id="enableTopPadding">
                        <label for="enableTopPadding" style="font-size: 12px;">Top:</label>
                        <input type="number" id="topPadding" min="0" max="100" value="10" style="width: 50px;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="checkbox" id="enableRightPadding">
                        <label for="enableRightPadding" style="font-size: 12px;">Right:</label>
                        <input type="number" id="rightPadding" min="0" max="100" value="10" style="width: 50px;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="checkbox" id="enableBottomPadding">
                        <label for="enableBottomPadding" style="font-size: 12px;">Bottom:</label>
                        <input type="number" id="bottomPadding" min="0" max="100" value="10" style="width: 50px;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 4px;">
                        <input type="checkbox" id="enableLeftPadding">
                        <label for="enableLeftPadding" style="font-size: 12px;">Left:</label>
                        <input type="number" id="leftPadding" min="0" max="100" value="10" style="width: 50px;">
                    </div>
                </div>


            </div>


        </div>
    </div>



    <script>
        // CONFIGURATION: Set the range for missing image detection
        const BG_START = 1;    // Start number (bg1)
        let BG_END = 1;        // Will be auto-detected from actual files

        // Array to track images with incorrect dimensions
        const incorrectDimensionImages = [];

        // Image usage data from JSON
        let imageUsageData = {};

        // Array to store discovered image files
        let svgFiles = [];

        // Guide line settings
        const guideSettings = {
            enableCorrectDimensionCheck: true,
            centerVertical: true,
            centerHorizontal: true,
            verticalDivisions: false,
            horizontalDivisions: false,
            verticalDivisionCount: 3,
            horizontalDivisionCount: 3,
            showVisualCenter: false,
            usageFilter: 'all', // 'all', 'used', 'unused'
            dimensionFilters: {
                correct: true,
                incorrect: true
            },
            categoryFilters: {
                hr: true,
                settings: true,
                profile: true,
                request: true,
                other: true,
                shared: true
            },
            padding: {
                all: false,
                top: false,
                right: false,
                bottom: false,
                left: false,
                xAxis: false,
                yAxis: false
            },
            paddingValues: {
                all: 15,
                top: 10,
                right: 10,
                bottom: 10,
                left: 10
            }
        };

        // Function to automatically discover all SVG files in the img folder
        async function discoverImageFiles() {
            const imgFolder = './img/';
            
            // Try to load the file list from a generated JSON file first
            try {
                const response = await fetch('./img/file-list.json');
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Loaded file list from file-list.json');
                    
                    // Extract max bg number from the files
                    let maxBgNumber = 0;
                    data.files.forEach(filename => {
                        const match = filename.match(/^bg(\d+)\.svg$/);
                        if (match) {
                            const num = parseInt(match[1]);
                            if (num > maxBgNumber) {
                                maxBgNumber = num;
                            }
                        }
                    });
                    BG_END = maxBgNumber;
                    console.log(`üìä Detected bg range: bg${BG_START}.svg to bg${BG_END}.svg`);
                    
                    return data.files.map(f => imgFolder + f);
                }
            } catch (e) {
                console.log('No file-list.json found, trying alternative methods...');
            }

            // Fallback: Try to detect files by probing
            // Start with a reasonable upper limit and probe to find the max
            const probeLimit = 200;
            const patterns = [];
            
            // Add bg files from BG_START to probeLimit
            for (let i = BG_START; i <= probeLimit; i++) {
                patterns.push(`bg${i}.svg`);
            }
            
            // Add required utility files
            patterns.push('filter.svg', 'search.svg');

            // Test each file to see if it exists
            const existenceChecks = patterns.map(async (filename) => {
                try {
                    const response = await fetch(imgFolder + filename, { method: 'HEAD' });
                    if (response.ok) {
                        return filename;
                    }
                } catch (e) {
                    return null;
                }
                return null;
            });

            const results = await Promise.all(existenceChecks);
            const existingFiles = results.filter(f => f !== null);
            
            // Find the maximum bg number from existing files
            let maxBgNumber = 0;
            existingFiles.forEach(filename => {
                const match = filename.match(/^bg(\d+)\.svg$/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num > maxBgNumber) {
                        maxBgNumber = num;
                    }
                }
            });
            BG_END = maxBgNumber;
            
            console.log(`‚úÖ Discovered ${existingFiles.length} SVG files`);
            console.log(`üìä Detected bg range: bg${BG_START}.svg to bg${BG_END}.svg`);
            
            return existingFiles.map(f => imgFolder + f);
        }

        function createImageItem(filepath) {
            const imageItem = document.createElement('div');
            imageItem.className = 'image-item';

            // Extract just the filename from the path
            const filename = filepath.split('/').pop();

            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';

            const img = document.createElement('img');
            img.src = filepath;
            img.alt = filename;

            const gridOverlay = document.createElement('div');
            gridOverlay.className = 'grid-overlay';

            // Create and append guide lines
            updateGuideLines(gridOverlay);

            imageContainer.appendChild(img);
            imageContainer.appendChild(gridOverlay);

            const imageInfo = document.createElement('div');
            imageInfo.className = 'image-info';

            const filenameDiv = document.createElement('div');
            filenameDiv.className = 'filename';
            filenameDiv.textContent = filename;

            const dimensionsDiv = document.createElement('div');
            dimensionsDiv.className = 'dimensions';
            dimensionsDiv.textContent = 'Loading...';



            img.onload = function () {
                const width = this.naturalWidth || this.width;
                const height = this.naturalHeight || this.height;

                dimensionsDiv.textContent = `${width} √ó ${height}px`;

                // Check if dimensions are 196x121 and add correct-dimensions class
                if (width === 196 && height === 121) {
                    if (guideSettings.enableCorrectDimensionCheck) {
                        imageItem.classList.add('correct-dimensions');
                    }
                } else {
                    // Add to incorrect dimensions list
                    incorrectDimensionImages.push({
                        filename: filename,
                        width: width,
                        height: height
                    });
                    updateIncorrectDimensionsList();
                }
            };

            img.onerror = function () {
                dimensionsDiv.textContent = 'File not found';
            };

            imageInfo.appendChild(filenameDiv);
            imageInfo.appendChild(dimensionsDiv);

            // Add breadcrumb information
            const breadcrumbDiv = document.createElement('div');
            breadcrumbDiv.className = 'breadcrumb-info';
            
            // Try to find usage data with both .svg and .png extensions
            const baseFilename = filename.replace(/\.(svg|png)$/i, '');
            const usagePaths = imageUsageData[filename] || 
                              imageUsageData[baseFilename + '.png'] || 
                              imageUsageData[baseFilename + '.svg'] || 
                              [];
            
            if (usagePaths.length > 0) {
                usagePaths.forEach(path => {
                    const category = path.split(' > ')[0].toLowerCase();

                    // Only show breadcrumb if category is enabled
                    if (['hr', 'settings', 'profile', 'request', 'other', 'shared'].includes(category) &&
                        guideSettings.categoryFilters[category]) {
                        const pathSpan = document.createElement('span');
                        pathSpan.className = 'breadcrumb-path';
                        pathSpan.classList.add(`category-${category}`);
                        pathSpan.textContent = path;
                        breadcrumbDiv.appendChild(pathSpan);
                    }
                });
            }

            // Only append breadcrumb div if it has content
            if (breadcrumbDiv.children.length > 0) {
                imageInfo.appendChild(breadcrumbDiv);
            }

            imageItem.appendChild(imageContainer);
            imageItem.appendChild(imageInfo);

            return imageItem;
        }

        // Function to find missing images between configurable range
        function findMissingImages() {
            const existingNumbers = [];
            const missingNumbers = [];

            // Extract numbers from bg files in our list
            svgFiles.forEach(filepath => {
                // Extract just the filename from the path
                const filename = filepath.split('/').pop();
                const match = filename.match(/^bg(\d+)\.svg$/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num >= BG_START && num <= BG_END) {
                        existingNumbers.push(num);
                    }
                }
            });

            // Find missing numbers between BG_START and BG_END
            for (let i = BG_START; i <= BG_END; i++) {
                if (!existingNumbers.includes(i)) {
                    missingNumbers.push(i);
                }
            }

            return missingNumbers;
        }

        // Display missing images
        function displayMissingImages() {
            const missingNumbers = findMissingImages();
            const missingList = document.getElementById('missingList');
            const missingSection = document.getElementById('missingImages');
            const missingTitle = document.getElementById('missingTitle');

            // Update title with current range and count
            if (missingNumbers.length === 0) {
                missingSection.style.display = 'none';
            } else {
                missingSection.style.display = 'block';
                missingTitle.textContent = `Missing Names (${missingNumbers.length})`;
            }
            missingNumbers.forEach(num => {
                const missingItem = document.createElement('li');
                missingItem.className = 'missing-item';
                // Show only the number without extension for compact display
                missingItem.textContent = `bg${num}`;
                missingItem.title = `bg${num}.svg`; // Tooltip shows full name
                missingList.appendChild(missingItem);
            });
        }

        // Update incorrect dimensions list
        function updateIncorrectDimensionsList() {
            const incorrectList = document.getElementById('incorrectList');
            const incorrectSection = document.getElementById('incorrectDimensions');

            // Clear existing items
            incorrectList.innerHTML = '';

            // Update title with count
            const incorrectTitle = document.getElementById('incorrectDimensionsTitle');

            if (incorrectDimensionImages.length === 0) {
                incorrectSection.style.display = 'none';
            } else {
                incorrectSection.style.display = 'block';
                incorrectTitle.textContent = `Incorrect Dimensions (${incorrectDimensionImages.length})`;

                // Sort incorrect dimensions in numerical order
                const sortedIncorrectImages = incorrectDimensionImages.sort((a, b) => {
                    const aMatch = a.filename.match(/^([a-zA-Z]+)(\d+)\.svg$/);
                    const bMatch = b.filename.match(/^([a-zA-Z]+)(\d+)\.svg$/);

                    if (aMatch && bMatch) {
                        const aPrefix = aMatch[1];
                        const bPrefix = bMatch[1];
                        const aNum = parseInt(aMatch[2]);
                        const bNum = parseInt(bMatch[2]);

                        // First sort by prefix
                        if (aPrefix !== bPrefix) {
                            return aPrefix.localeCompare(bPrefix);
                        }
                        // Then sort by number
                        return aNum - bNum;
                    }

                    // Fallback to alphabetical sorting for non-numbered files
                    return a.filename.localeCompare(b.filename);
                });

                sortedIncorrectImages.forEach(item => {
                    const incorrectItem = document.createElement('li');
                    incorrectItem.className = 'compact-incorrect-item';
                    // Show only filename without extension
                    const displayName = item.filename.replace('.svg', '');
                    incorrectItem.textContent = displayName;
                    incorrectItem.title = `${item.filename} (${item.width}√ó${item.height})`; // Tooltip

                    // Add click to scroll functionality
                    incorrectItem.addEventListener('click', () => {
                        scrollToImage(item.filename);
                    });

                    incorrectList.appendChild(incorrectItem);
                });
            }
        }

        // Scroll to specific image in the grid
        function scrollToImage(filename) {
            const imageItems = document.querySelectorAll('.image-item');
            imageItems.forEach(item => {
                const filenameElement = item.querySelector('.filename');
                if (filenameElement && filenameElement.textContent === filename) {
                    item.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    // Highlight the image briefly
                    item.style.boxShadow = '0 0 20px #ff6600';
                    setTimeout(() => {
                        item.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                    }, 2000);
                }
            });
        }



        // Function to create guide lines based on settings
        function updateGuideLines(overlay) {
            // Clear existing lines
            overlay.innerHTML = '';

            // Center guidelines
            if (guideSettings.centerVertical) {
                const verticalLine = document.createElement('div');
                verticalLine.className = 'grid-line-v';
                overlay.appendChild(verticalLine);
            }

            if (guideSettings.centerHorizontal) {
                const horizontalLine = document.createElement('div');
                horizontalLine.className = 'grid-line-h';
                overlay.appendChild(horizontalLine);
            }

            // Division guidelines
            if (guideSettings.verticalDivisions) {
                for (let i = 1; i < guideSettings.verticalDivisionCount; i++) {
                    const line = document.createElement('div');
                    line.className = 'grid-line-division-v';
                    line.style.left = `${(i / guideSettings.verticalDivisionCount) * 100}%`;
                    overlay.appendChild(line);
                }
            }

            if (guideSettings.horizontalDivisions) {
                for (let i = 1; i < guideSettings.horizontalDivisionCount; i++) {
                    const line = document.createElement('div');
                    line.className = 'grid-line-division-h';
                    line.style.top = `${(i / guideSettings.horizontalDivisionCount) * 100}%`;
                    overlay.appendChild(line);
                }
            }

            // Padding guidelines
            const paddingChecks = [
                {
                    enabled: guideSettings.padding.all || guideSettings.padding.top,
                    class: 'padding-line-top',
                    style: 'top',
                    value: guideSettings.paddingValues.top
                },
                {
                    enabled: guideSettings.padding.all || guideSettings.padding.bottom,
                    class: 'padding-line-bottom',
                    style: 'bottom',
                    value: guideSettings.paddingValues.bottom
                },
                {
                    enabled: guideSettings.padding.all || guideSettings.padding.left,
                    class: 'padding-line-left',
                    style: 'left',
                    value: guideSettings.paddingValues.left
                },
                {
                    enabled: guideSettings.padding.all || guideSettings.padding.right,
                    class: 'padding-line-right',
                    style: 'right',
                    value: guideSettings.paddingValues.right
                }
            ];

            paddingChecks.forEach(check => {
                if (check.enabled) {
                    const line = document.createElement('div');
                    line.className = check.class;
                    line.style[check.style] = `${check.value}px`;
                    overlay.appendChild(line);
                }
            });

            // Visual center marker
            if (guideSettings.showVisualCenter) {
                addVisualCenterMarker(overlay);
            }
        }

        // Function to add visual center marker
        function addVisualCenterMarker(overlay) {
            const imageContainer = overlay.parentElement;
            const img = imageContainer.querySelector('img');

            if (img) {
                if (img.complete && img.naturalWidth > 0) {
                    // Image is loaded, analyze immediately
                    if (img.src.endsWith('.svg')) {
                        analyzeAndMarkSVGCenter(img, overlay);
                    }
                } else {
                    // Wait for image to load
                    const loadHandler = () => {
                        if (img.src.endsWith('.svg')) {
                            analyzeAndMarkSVGCenter(img, overlay);
                        }
                        img.removeEventListener('load', loadHandler);
                    };

                    const errorHandler = () => {
                        // If image fails to load, still show estimated center
                        addEstimatedVisualCenter(img, overlay);
                        img.removeEventListener('error', errorHandler);
                        img.removeEventListener('load', loadHandler);
                    };

                    img.addEventListener('load', loadHandler);
                    img.addEventListener('error', errorHandler);

                    // Fallback timeout in case events don't fire
                    setTimeout(() => {
                        if (!overlay.querySelector('.visual-center-marker')) {
                            addEstimatedVisualCenter(img, overlay);
                        }
                    }, 2000);
                }
            }
        }

        // Function to analyze SVG and mark visual center
        function analyzeAndMarkSVGCenter(img, overlay) {
            // First try the direct method (works when served via HTTP)
            tryDirectSVGAnalysis(img, overlay)
                .catch(() => {
                    // Fallback: Use embedded SVG method (works with file:// protocol)
                    tryEmbeddedSVGAnalysis(img, overlay);
                });
        }

        // Direct SVG analysis using fetch (works with live server)
        function tryDirectSVGAnalysis(img, overlay) {
            return fetch(img.src)
                .then(response => {
                    if (!response.ok) throw new Error('Fetch failed');
                    return response.text();
                })
                .then(svgText => {
                    analyzeSVGContent(svgText, overlay);
                });
        }

        // Embedded SVG analysis (works with file:// protocol)
        function tryEmbeddedSVGAnalysis(img, overlay) {
            // Create a new image element to load the SVG as an object
            const object = document.createElement('object');
            object.data = img.src;
            object.type = 'image/svg+xml';
            object.style.position = 'absolute';
            object.style.visibility = 'hidden';
            object.style.width = '0';
            object.style.height = '0';

            object.onload = function() {
                try {
                    const svgDoc = object.contentDocument;
                    if (svgDoc) {
                        const svgElement = svgDoc.documentElement;
                        analyzeSVGElement(svgElement, overlay);
                    } else {
                        // Final fallback: estimate visual center based on filename patterns
                        addEstimatedVisualCenter(img, overlay);
                    }
                } catch (error) {
                    console.warn('Could not analyze embedded SVG:', error);
                    addEstimatedVisualCenter(img, overlay);
                } finally {
                    document.body.removeChild(object);
                }
            };

            object.onerror = function() {
                console.warn('Could not load SVG as object');
                addEstimatedVisualCenter(img, overlay);
                document.body.removeChild(object);
            };

            document.body.appendChild(object);
        }

        // Analyze SVG content from text
        function analyzeSVGContent(svgText, overlay) {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;

            // Add to DOM temporarily to get bbox
            svgElement.style.position = 'absolute';
            svgElement.style.visibility = 'hidden';
            document.body.appendChild(svgElement);

            try {
                analyzeSVGElement(svgElement, overlay);
            } finally {
                document.body.removeChild(svgElement);
            }
        }

        // Analyze SVG element and create visual center marker
        function analyzeSVGElement(svgElement, overlay) {
            try {
                // Get SVG dimensions
                const viewBox = svgElement.viewBox.baseVal;
                const canvasWidth = viewBox.width || 196;
                const canvasHeight = viewBox.height || 121;

                // Get content bounding box
                const bbox = svgElement.getBBox();

                // Calculate visual center
                const visualCenterX = bbox.x + bbox.width / 2;
                const visualCenterY = bbox.y + bbox.height / 2;

                // Convert to percentage of image dimensions
                const centerXPercent = (visualCenterX / canvasWidth) * 100;
                const centerYPercent = (visualCenterY / canvasHeight) * 100;

                // Create marker
                const marker = document.createElement('div');
                marker.className = 'visual-center-marker';
                marker.style.left = `${centerXPercent}%`;
                marker.style.top = `${centerYPercent}%`;
                marker.title = `Visual Center: (${Math.round(visualCenterX)}, ${Math.round(visualCenterY)})`;

                overlay.appendChild(marker);

            } catch (error) {
                console.warn('Could not analyze SVG element:', error);
                addEstimatedVisualCenter(null, overlay);
            }
        }

        // Fallback: Add estimated visual center (slightly off-center for most icons)
        function addEstimatedVisualCenter(img, overlay) {
            // Most icons have visual weight slightly above and to the left of geometric center
            const estimatedXPercent = 48; // Slightly left of center
            const estimatedYPercent = 47; // Slightly above center

            const marker = document.createElement('div');
            marker.className = 'visual-center-marker';
            marker.style.left = `${estimatedXPercent}%`;
            marker.style.top = `${estimatedYPercent}%`;
            marker.style.backgroundColor = '#ff9800'; // Different color to indicate estimation
            marker.title = 'Estimated Visual Center (SVG analysis unavailable)';

            overlay.appendChild(marker);
        }

        // Function to load and process image usage data
        function loadImageUsageData() {
            // Try fetch first (works with live server)
            fetch('./image-data.json')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('‚úÖ Loaded JSON data successfully via fetch'); // Debug log
                    imageUsageData = processImageUsage(data);
                    console.log('üìä Processed', Object.keys(imageUsageData).length, 'images with usage data'); // Debug log
                    // Refresh the image grid to show breadcrumbs
                    refreshImageGrid();
                    displayUnusedImages();
                    showJSONLoadSuccess();
                })
                .catch(error => {
                    console.error('Could not load image usage data via fetch:', error);
                    console.log('Trying alternative method...');
                    // Fallback: Try to load via script injection
                    loadJSONViaScript();
                });
        }

        // Alternative method to load JSON (works with file:// protocol)
        function loadJSONViaScript() {
            // Create a script element to load JSON as JSONP
            const script = document.createElement('script');
            script.src = './image-data.json';
            script.onerror = function() {
                console.error('Could not load JSON via script tag either');
                console.log('Please use a live server or manually embed the JSON data');
                showJSONLoadError();
            };
            
            // Try to read as text using XMLHttpRequest (sometimes works)
            const xhr = new XMLHttpRequest();
            xhr.open('GET', './image-data.json', true);
            xhr.overrideMimeType('application/json');
            
            xhr.onload = function() {
                if (xhr.status === 200 || xhr.status === 0) { // 0 for file:// protocol
                    try {
                        const data = JSON.parse(xhr.responseText);
                        console.log('‚úÖ Loaded JSON data successfully via XHR'); // Debug log
                        imageUsageData = processImageUsage(data);
                        console.log('üìä Processed', Object.keys(imageUsageData).length, 'images with usage data'); // Debug log
                        refreshImageGrid();
                        displayUnusedImages();
                        showJSONLoadSuccess();
                    } catch (e) {
                        console.error('Error parsing JSON:', e);
                        showJSONLoadError();
                    }
                } else {
                    console.error('XHR failed with status:', xhr.status);
                    showJSONLoadError();
                }
            };
            
            xhr.onerror = function() {
                console.error('XHR request failed');
                showJSONLoadError();
            };
            
            try {
                xhr.send();
            } catch (e) {
                console.error('Could not send XHR request:', e);
                showJSONLoadError();
            }
        }

        // Show success message when JSON is loaded
        function showJSONLoadSuccess() {
            const filterBtn = document.getElementById('filterDropdownBtn');
            if (filterBtn) {
                filterBtn.style.backgroundColor = '#d4edda';
                filterBtn.style.borderColor = '#28a745';
                filterBtn.title = 'Breadcrumb data loaded successfully';
                
                // Reset to normal after 2 seconds
                setTimeout(() => {
                    filterBtn.style.backgroundColor = 'white';
                    filterBtn.style.borderColor = '#ccc';
                    filterBtn.title = '';
                }, 2000);
            }
        }

        // Show error message when JSON cannot be loaded
        function showJSONLoadError() {
            console.warn('‚ö†Ô∏è Breadcrumb data unavailable');
            console.log('üí° To see breadcrumbs:');
            console.log('   1. Use a live server (recommended)');
            console.log('   2. Or run: python -m http.server 8000');
            console.log('   3. Then open: http://localhost:8000/image-viewer.html');
            
            // Add visual indicator in the UI
            const filterBtn = document.getElementById('filterDropdownBtn');
            if (filterBtn) {
                filterBtn.style.backgroundColor = '#fff3cd';
                filterBtn.style.borderColor = '#ffc107';
                filterBtn.title = 'Breadcrumb data unavailable - Use live server to enable';
            }
        }

        // Function to process JSON data and extract image usage paths
        function processImageUsage(data) {
            const usage = {};

            function traverse(obj, path = []) {
                for (const [key, value] of Object.entries(obj)) {
                    const currentPath = [...path, key];

                    if (typeof value === 'object' && value !== null) {
                        // Check if this object has an "img" property
                        if (value.img && typeof value.img === 'string') {
                            const imgName = value.img;
                            if (!usage[imgName]) {
                                usage[imgName] = [];
                            }
                            usage[imgName].push(currentPath.join(' > '));
                        }
                        // Continue traversing nested objects
                        traverse(value, currentPath);
                    }
                }
            }

            traverse(data);
            console.log('Processed image usage:', usage); // Debug log
            return usage;
        }

        // Function to display unused images
        function displayUnusedImages() {
            const unusedList = document.getElementById('unusedList');
            const unusedSection = document.getElementById('unusedImages');
            const unusedTitle = document.getElementById('unusedTitle');
            
            // Clear existing items
            unusedList.innerHTML = '';
            
            const unusedImages = [];
            
            // Check each SVG file to see if it's used
            svgFiles.forEach(filepath => {
                // Extract just the filename from the path
                const filename = filepath.split('/').pop();
                const baseFilename = filename.replace(/\.(svg|png)$/i, '');
                const usagePaths = imageUsageData[filename] || 
                                  imageUsageData[baseFilename + '.png'] || 
                                  imageUsageData[baseFilename + '.svg'] || 
                                  [];
                
                if (usagePaths.length === 0) {
                    unusedImages.push(filename);
                }
            });
            
            // Sort unused images
            unusedImages.sort((a, b) => {
                const aMatch = a.match(/^bg(\d+)\.svg$/);
                const bMatch = b.match(/^bg(\d+)\.svg$/);
                
                if (aMatch && bMatch) {
                    const aNum = parseInt(aMatch[1]);
                    const bNum = parseInt(bMatch[1]);
                    return aNum - bNum;
                }
                
                return a.localeCompare(b);
            });
            
            if (unusedImages.length === 0) {
                unusedSection.style.display = 'none';
            } else {
                unusedSection.style.display = 'block';
                unusedTitle.textContent = `Unused Images (${unusedImages.length})`;
                
                unusedImages.forEach(filename => {
                    const unusedItem = document.createElement('li');
                    unusedItem.className = 'unused-item';
                    const displayName = filename.replace(/\.svg$/i, '');
                    unusedItem.textContent = displayName;
                    unusedItem.title = filename;
                    
                    // Add click to scroll functionality
                    unusedItem.addEventListener('click', () => {
                        scrollToImage(filename);
                    });
                    
                    unusedList.appendChild(unusedItem);
                });
            }
        }

        // Function to refresh image grid with breadcrumb data and apply filters
        function refreshImageGrid() {
            const imageGrid = document.getElementById('imageGrid');
            const existingItems = imageGrid.querySelectorAll('.image-item');

            console.log('Refreshing grid with usage data:', Object.keys(imageUsageData).length, 'images found'); // Debug

            existingItems.forEach(item => {
                const filename = item.querySelector('.filename').textContent;
                const existingBreadcrumb = item.querySelector('.breadcrumb-info');
                if (existingBreadcrumb) {
                    existingBreadcrumb.remove();
                }

                // Add new breadcrumb info
                const imageInfo = item.querySelector('.image-info');
                const breadcrumbDiv = document.createElement('div');
                breadcrumbDiv.className = 'breadcrumb-info';
                const usagePaths = imageUsageData[filename] || [];

                console.log(`Image ${filename}: found ${usagePaths.length} usage paths`); // Debug

                const isUsed = usagePaths.length > 0;

                if (isUsed) {
                    usagePaths.forEach(path => {
                        const category = path.split(' > ')[0].toLowerCase();

                        // Only show breadcrumb if category is enabled
                        if (['hr', 'settings', 'profile', 'request', 'other', 'shared'].includes(category) &&
                            guideSettings.categoryFilters[category]) {
                            const pathSpan = document.createElement('span');
                            pathSpan.className = 'breadcrumb-path';
                            pathSpan.classList.add(`category-${category}`);
                            pathSpan.textContent = path;
                            breadcrumbDiv.appendChild(pathSpan);
                        }
                    });
                }

                // Only append breadcrumb div if it has content
                if (breadcrumbDiv.children.length > 0) {
                    imageInfo.appendChild(breadcrumbDiv);
                }

                // Apply visibility filter based on usage and settings
                const categories = getCategoriesFromPaths(usagePaths);
                const correctDimensions = hasCorrectDimensions(item);
                applyImageFilter(item, isUsed, categories, correctDimensions);
            });
        }

        // Function to apply image filter based on usage, category, and dimensions
        function applyImageFilter(imageItem, isUsed, categories, hasCorrectDimensions) {
            const usageFilter = guideSettings.usageFilter;
            const categoryFilters = guideSettings.categoryFilters;
            const dimensionFilters = guideSettings.dimensionFilters;

            // Check usage filter
            let passesUsageFilter = false;
            if (usageFilter === 'all') {
                passesUsageFilter = true;
            } else if (usageFilter === 'used' && isUsed) {
                passesUsageFilter = true;
            } else if (usageFilter === 'unused' && !isUsed) {
                passesUsageFilter = true;
            }

            // Check dimension filter
            let passesDimensionFilter = false;
            if (hasCorrectDimensions && dimensionFilters.correct) {
                passesDimensionFilter = true;
            } else if (!hasCorrectDimensions && dimensionFilters.incorrect) {
                passesDimensionFilter = true;
            }

            // Check category filter
            let passesCategoryFilter = false;
            if (!isUsed) {
                // Unused images are always shown if they pass other filters
                passesCategoryFilter = true;
            } else {
                // Check if any of the image's categories are enabled
                categories.forEach(category => {
                    if (categoryFilters[category]) {
                        passesCategoryFilter = true;
                    }
                });
                // If no categories are enabled, don't show any used images
                if (Object.values(categoryFilters).every(enabled => !enabled)) {
                    passesCategoryFilter = false;
                }
            }

            if (passesUsageFilter && passesDimensionFilter && passesCategoryFilter) {
                imageItem.style.display = 'block';
            } else {
                imageItem.style.display = 'none';
            }
        }

        // Function to get categories from usage paths
        function getCategoriesFromPaths(usagePaths) {
            const categories = new Set();
            usagePaths.forEach(path => {
                const category = path.split(' > ')[0].toLowerCase();
                if (['hr', 'settings', 'profile', 'request', 'other', 'shared'].includes(category)) {
                    categories.add(category);
                }
            });
            return Array.from(categories);
        }

        // Function to check if image has correct dimensions
        function hasCorrectDimensions(imageItem) {
            return imageItem.classList.contains('correct-dimensions');
        }

        // Function to filter all images based on current settings
        function filterAllImages() {
            const imageGrid = document.getElementById('imageGrid');
            const existingItems = imageGrid.querySelectorAll('.image-item');

            existingItems.forEach(item => {
                const filename = item.querySelector('.filename').textContent;
                const usagePaths = imageUsageData[filename] || [];
                const isUsed = usagePaths.length > 0;
                const categories = getCategoriesFromPaths(usagePaths);
                const correctDimensions = hasCorrectDimensions(item);
                applyImageFilter(item, isUsed, categories, correctDimensions);
            });
        }

        // Function to update division labels
        function updateDivisionLabels() {
            const verticalCount = parseInt(document.getElementById('verticalDivisions').value);
            const horizontalCount = parseInt(document.getElementById('horizontalDivisions').value);

            const verticalPixels = Math.round(196 / verticalCount);
            const horizontalPixels = Math.round(121 / horizontalCount);

            document.getElementById('verticalDivisionValue').textContent = `${verticalPixels}px`;
            document.getElementById('horizontalDivisionValue').textContent = `${horizontalPixels}px`;
        }

        // Function to update all guide lines
        function updateAllGuideLines() {
            document.querySelectorAll('.grid-overlay').forEach(overlay => {
                updateGuideLines(overlay);
            });
        }

        // Function to update correct dimension highlighting
        function updateCorrectDimensionHighlighting() {
            document.querySelectorAll('.image-item').forEach(item => {
                if (guideSettings.enableCorrectDimensionCheck) {
                    // Check if this item should have correct dimensions class
                    const dimensionsText = item.querySelector('.dimensions').textContent;
                    if (dimensionsText.includes('196 √ó 121')) {
                        item.classList.add('correct-dimensions');
                    }
                } else {
                    item.classList.remove('correct-dimensions');
                }
            });
        }

        // Function to update grid size and scale images
        function updateGridSize(columns) {
            const imageGrid = document.getElementById('imageGrid');
            imageGrid.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
            document.getElementById('gridSizeValue').textContent = columns;
        }

        // Event listeners for toolkit controls
        function setupToolkitControls() {
            // Grid size slider
            document.getElementById('gridSizeSlider').addEventListener('input', (e) => {
                updateGridSize(e.target.value);
            });

            // Correct dimension check toggle (main title)
            document.getElementById('mainCorrectDimensionCheck').addEventListener('change', (e) => {
                guideSettings.enableCorrectDimensionCheck = e.target.checked;
                updateCorrectDimensionHighlighting();
            });

            // Center guidelines
            document.getElementById('centerVertical').addEventListener('change', (e) => {
                guideSettings.centerVertical = e.target.checked;
                updateAllGuideLines();
            });

            document.getElementById('centerHorizontal').addEventListener('change', (e) => {
                guideSettings.centerHorizontal = e.target.checked;
                updateAllGuideLines();
            });

            // Division guidelines
            document.getElementById('enableVerticalDivisions').addEventListener('change', (e) => {
                guideSettings.verticalDivisions = e.target.checked;
                updateAllGuideLines();
            });

            document.getElementById('enableHorizontalDivisions').addEventListener('change', (e) => {
                guideSettings.horizontalDivisions = e.target.checked;
                updateAllGuideLines();
            });

            document.getElementById('verticalDivisions').addEventListener('input', (e) => {
                guideSettings.verticalDivisionCount = parseInt(e.target.value);
                updateDivisionLabels();
                updateAllGuideLines();
            });

            document.getElementById('horizontalDivisions').addEventListener('input', (e) => {
                guideSettings.horizontalDivisionCount = parseInt(e.target.value);
                updateDivisionLabels();
                updateAllGuideLines();
            });

            // Visual center toggle
            document.getElementById('showVisualCenter').addEventListener('change', (e) => {
                guideSettings.showVisualCenter = e.target.checked;
                updateAllGuideLines();
            });

            // Filter dropdown toggle
            document.getElementById('filterDropdownBtn').addEventListener('click', (e) => {
                e.stopPropagation();
                const dropdown = document.getElementById('filterDropdown');
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('filterDropdown');
                const btn = document.getElementById('filterDropdownBtn');
                if (!dropdown.contains(e.target) && !btn.contains(e.target)) {
                    dropdown.style.display = 'none';
                }
            });

            // Usage filter radio buttons
            document.querySelectorAll('input[name="usageFilter"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    guideSettings.usageFilter = e.target.value;
                    filterAllImages();
                });
            });

            // Dimension filter checkboxes
            document.querySelectorAll('.dimension-filter').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    guideSettings.dimensionFilters[e.target.value] = e.target.checked;
                    filterAllImages();
                });
            });

            // Select All Categories checkbox
            document.getElementById('selectAllCategories').addEventListener('change', (e) => {
                const isChecked = e.target.checked;

                // Update all category filters
                Object.keys(guideSettings.categoryFilters).forEach(category => {
                    guideSettings.categoryFilters[category] = isChecked;
                });

                // Update all category checkboxes
                document.querySelectorAll('.category-filter').forEach(checkbox => {
                    checkbox.checked = isChecked;
                });

                refreshImageGrid(); // Refresh to update breadcrumbs
            });

            // Category filter checkboxes
            document.querySelectorAll('.category-filter').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    guideSettings.categoryFilters[e.target.value] = e.target.checked;

                    // Update Select All checkbox state
                    const allChecked = Object.values(guideSettings.categoryFilters).every(checked => checked);
                    const noneChecked = Object.values(guideSettings.categoryFilters).every(checked => !checked);
                    const selectAllCheckbox = document.getElementById('selectAllCategories');

                    if (allChecked) {
                        selectAllCheckbox.checked = true;
                        selectAllCheckbox.indeterminate = false;
                    } else if (noneChecked) {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = false;
                    } else {
                        selectAllCheckbox.checked = false;
                        selectAllCheckbox.indeterminate = true; // Mixed state
                    }

                    refreshImageGrid(); // Refresh to update breadcrumbs
                });
            });

            // Padding guidelines
            document.getElementById('enableAllPadding').addEventListener('change', (e) => {
                guideSettings.padding.all = e.target.checked;
                updateAllGuideLines();
            });

            document.getElementById('allPadding').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                guideSettings.paddingValues.all = value;
                guideSettings.paddingValues.top = value;
                guideSettings.paddingValues.right = value;
                guideSettings.paddingValues.bottom = value;
                guideSettings.paddingValues.left = value;
                updateAllGuideLines();
            });

            // Individual padding controls
            ['top', 'right', 'bottom', 'left'].forEach(side => {
                document.getElementById(`enable${side.charAt(0).toUpperCase() + side.slice(1)}Padding`).addEventListener('change', (e) => {
                    guideSettings.padding[side] = e.target.checked;
                    updateAllGuideLines();
                });

                document.getElementById(`${side}Padding`).addEventListener('input', (e) => {
                    guideSettings.paddingValues[side] = parseInt(e.target.value);
                    updateAllGuideLines();
                });
            });


        }

        // Initialize the application
        async function initializeApp() {
            const imageGrid = document.getElementById('imageGrid');

            // Discover all image files
            svgFiles = await discoverImageFiles();

            // Display missing images first
            displayMissingImages();

            // Create image items for each image file
            svgFiles.forEach(filepath => {
                const imageItem = createImageItem(filepath);
                imageGrid.appendChild(imageItem);
            });

            // Setup toolkit controls
            setupToolkitControls();

            // Initialize division labels
            updateDivisionLabels();

            // Load and process image usage data
            loadImageUsageData();
        }

        // Start the application
        initializeApp();


    </script>
</body>

</html>